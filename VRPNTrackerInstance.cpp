/* ========================================================================
 * PROJECT: UART
 * ========================================================================
 * Portions of this work are built on top of VRPN which was developed by
 *   Russell Taylor
 *   University of North Carolina
 * http://www.cs.unc.edu/Research/vrpn/
 *
 * We acknowledge the CISMM project at the University of North Carolina at Chapel Hill, supported by NIH/NCRR
 * and NIH/NIBIB award #2P41EB002025, for their ongoing  * support and maintenance of VRPN.
 *
 * Portions of this work are also built on top of the VideoWrapper,
 * a BSD licensed video access library for MacOSX and Windows.
 * VideoWrapper is available at SourceForge via
 * http://sourceforge.net/projects/videowrapper/
 *
 * Copyright of VideoWrapper is
 *     (C) 2003-2010 Georgia Tech Research Corportation
 *
 * Copyright of the new and derived portions of this work
 *     (C) 2010 Georgia Tech Research Corporation
 *
 * This software released under the Boost Software License 1.0 (BSL1.0), so as to be
 * compatible with the VRPN software distribution:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant,
 * this restriction and the following disclaimer, must be included in all copies of the Software, in
 * whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR
 * OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For further information regarding UART, please contact
 *   Blair MacIntyre
 *   <blair@cc.gatech.edu>
 *   Georgia Tech, School of Interactive Computing
 *   85 5th Street NW
 *   Atlanta, GA 30308
 *
 * For further information regarding VRPN, please contact
 *   Russell M. Taylor II
 *   <taylor@cs.unc.edu>
 *   University of North Carolina,
 *   CB #3175, Sitterson Hall,
 *   Chapel Hill, NC 27599-3175
 *
 * ========================================================================
 ** @author   Alex Hill (ahill@gatech.edu)
 *
 * ========================================================================
 *
 * VRPNTrackerInstance.cpp
 *
 * Usage:
 *
 *
 * Notes:
 *
 * ========================================================================*/

#if _MSC_VER // this is defined when compiling with Visual Studio
#define EXPORT_API __declspec(dllexport) // Visual Studio needs annotating exported functions with this
#else
#define EXPORT_API // XCode does not need annotating exported functions, so define is empty
#endif

#include "VRPNTrackerInstance.h"

void VRPN_CALLBACK handle_pos(void *userdata, const vrpn_TRACKERCB t)
{
	VRPNTrackerInstance *tracker = (VRPNTrackerInstance*)userdata;
	tracker->addPosReport(t);
}

void VRPN_CALLBACK handle_vel(void *userdata, const vrpn_TRACKERVELCB t)
{
	VRPNTrackerInstance *tracker = (VRPNTrackerInstance*)userdata;
	tracker->addVelReport(t);
}

void VRPN_CALLBACK handle_acc(void *userdata, const vrpn_TRACKERACCCB t)
{
	VRPNTrackerInstance *tracker = (VRPNTrackerInstance*)userdata;
	tracker->addAccReport(t);
}

VRPNTrackerInstance::VRPNTrackerInstance(const char* name, vrpn_Connection* connection)
{
	tracker = new vrpn_Tracker_Remote(name, connection);
	types = 0;
	maxReports = 1000;
}

VRPNTrackerInstance::~VRPNTrackerInstance()
{
	purgeReports();
	delete tracker;
}

void VRPNTrackerInstance::purgeReports()
{
	TrackerPosList::iterator PosItr;
	for ( PosItr = pos.begin(); PosItr != pos.end(); PosItr++ )
	{
		vrpn_TRACKERCB* curr = *PosItr;
		delete curr;
	}
	pos.erase(pos.begin(),pos.end());
	TrackerVelList::iterator VelItr;
	for ( VelItr = vel.begin(); VelItr != vel.end(); VelItr++ )
	{
		vrpn_TRACKERVELCB* curr = *VelItr;
		delete curr;
	}
	vel.erase(vel.begin(),vel.end());
	TrackerAccList::iterator AccItr;
	for ( AccItr = acc.begin(); AccItr != acc.end(); AccItr++ )
	{
		vrpn_TRACKERACCCB* curr = *AccItr;
		delete curr;
	}
	acc.erase(acc.begin(),acc.end());
}

vrpn_Tracker_Remote* VRPNTrackerInstance::getTracker()
{
	return tracker;
}

int VRPNTrackerInstance::getReportTypes()
{
	return types;
}

void VRPNTrackerInstance::setReportTypes(int in_types)
{
	if((in_types & 1) && !(types & 1))
	{
		tracker->register_change_handler(this,handle_pos);
	}
	else if (!(in_types & 1) && (types & 1))
	{
		tracker->unregister_change_handler(this,handle_pos);
	}

	if((in_types & 2) && !(types & 2))
	{
		tracker->register_change_handler(this,handle_vel);
	}
	else if (!(in_types & 2) && (types & 2))
	{
		tracker->unregister_change_handler(this,handle_vel);
	}

	if((in_types & 4) && !(types & 4))
	{
		tracker->register_change_handler(this,handle_acc);
	}
	else if (!(in_types & 4) && (types & 4))
	{
		tracker->unregister_change_handler(this,handle_acc);
	}
	types = in_types;
}

void VRPNTrackerInstance::setMaxReports(int max)
{
	maxReports = max;
}

void VRPNTrackerInstance::addPosReport(const vrpn_TRACKERCB& rep)
{
	vrpn_TRACKERCB* cpy = new vrpn_TRACKERCB;
	*cpy = rep;
	if (cpy->msg_time.tv_sec == 0.0)
		vrpn_gettimeofday(&cpy->msg_time,NULL);
	pos.push_front(cpy);
	if ((int)pos.size() > maxReports)
	{
		vrpn_TRACKERCB* rem = pos.back();
		pos.pop_back();
		delete rem;
	}
}

void VRPNTrackerInstance::addVelReport(const vrpn_TRACKERVELCB& rep)
{
	vrpn_TRACKERVELCB* cpy = new vrpn_TRACKERVELCB;
	*cpy = rep;
	vel.push_front(cpy);
	if ((int)vel.size() > maxReports)
	{
		vrpn_TRACKERVELCB* rem = vel.back();
		vel.pop_back();
		delete rem;
	}
}

void VRPNTrackerInstance::addAccReport(const vrpn_TRACKERACCCB& rep)
{
	vrpn_TRACKERACCCB* cpy = new vrpn_TRACKERACCCB;
	*cpy = rep;
	acc.push_front(cpy);
	if ((int)acc.size() > maxReports)
	{
		vrpn_TRACKERACCCB* rem = acc.back();
		acc.pop_back();
		delete rem;
	}
}

void VRPNTrackerInstance::getPosReport(vrpn_TRACKERCB* cpy, timeval* ts, int in_sensor)
{
	TrackerPosList::iterator it;
	vrpn_TRACKERCB* last = NULL;
	for ( it = pos.begin(); it != pos.end(); it++ )
	{
		vrpn_TRACKERCB* curr = *it;
		if (curr->sensor == in_sensor)
		{
			if (ts == NULL)
			{
				*cpy = *curr;
				return;
			}
			else if (vrpn_TimevalGreater(*ts,curr->msg_time))
			{
				if (last)
				{
					double val = vrpn_TimevalMsecs(vrpn_TimevalDiff(*ts, curr->msg_time))/vrpn_TimevalMsecs(vrpn_TimevalDiff(last->msg_time, curr->msg_time));
					cpy->pos[0] = curr->pos[0] + val*(last->pos[0] - curr->pos[0]);
					cpy->pos[1] = curr->pos[1] + val*(last->pos[1] - curr->pos[1]);
					cpy->pos[2] = curr->pos[2] + val*(last->pos[2] - curr->pos[2]);
					q_slerp(cpy->quat, curr->quat, last->quat, val);
					return;
				}
				else
				{
					*cpy = *curr;
					return;
				}
			}
			else
				last = curr;
		}
	}
}

void VRPNTrackerInstance::getVelReport(vrpn_TRACKERVELCB* cpy, timeval* ts, int in_sensor)
{
	TrackerVelList::iterator it;
	vrpn_TRACKERVELCB* last = NULL;
	for ( it = vel.begin(); it != vel.end(); it++ )
	{
		vrpn_TRACKERVELCB* curr = *it;
		if (curr->sensor == in_sensor)
		{
			if (ts == NULL)
			{
				*cpy = *curr;
				return;
			}
			else if (vrpn_TimevalGreater(*ts,curr->msg_time))
			{
				if (last)
				{
					double val = vrpn_TimevalMsecs(vrpn_TimevalDiff(*ts, curr->msg_time))/vrpn_TimevalMsecs(vrpn_TimevalDiff(last->msg_time, curr->msg_time));
					cpy->vel[0] = curr->vel[0] + val*(last->vel[0] - curr->vel[0]);
					cpy->vel[1] = curr->vel[1] + val*(last->vel[1] - curr->vel[1]);
					cpy->vel[2] = curr->vel[2] + val*(last->vel[2] - curr->vel[2]);
					q_slerp(cpy->vel_quat, last->vel_quat, curr->vel_quat, val);
					cpy->vel_quat_dt = curr->vel_quat_dt + val*(last->vel_quat_dt - curr->vel_quat_dt);
					return;
				}
				else
				{
					*cpy = *curr;
					return;
				}
			}
			else
				last = curr;
		}
	}
}

void VRPNTrackerInstance::getAccReport(vrpn_TRACKERACCCB* cpy, timeval* ts, int in_sensor)
{
	TrackerAccList::iterator it;
	vrpn_TRACKERACCCB* last = NULL;
	for ( it = acc.begin(); it != acc.end(); it++ )
	{
		vrpn_TRACKERACCCB* curr = *it;
		if (curr->sensor == in_sensor)
		{
			if (ts == NULL)
			{
				*cpy = *curr;
				return;
			}
			else if (vrpn_TimevalGreater(*ts,curr->msg_time))
			{
				if (last)
				{
					double val = vrpn_TimevalMsecs(vrpn_TimevalDiff(*ts, curr->msg_time))/vrpn_TimevalMsecs(vrpn_TimevalDiff(last->msg_time, curr->msg_time));
					cpy->acc[0] = curr->acc[0] + val*(last->acc[0] - curr->acc[0]);
					cpy->acc[1] = curr->acc[1] + val*(last->acc[1] - curr->acc[1]);
					cpy->acc[2] = curr->acc[2] + val*(last->acc[2] - curr->acc[2]);
					q_slerp(cpy->acc_quat, curr->acc_quat, last->acc_quat, val);
					cpy->acc_quat_dt = curr->acc_quat_dt + val*(last->acc_quat_dt - curr->acc_quat_dt);
					return;
				}
				else
				{
					*cpy = *curr;
					return;
				}
			}
			else
				last = curr;
		}
	}
}

int VRPNTrackerInstance::getNumPosReports()
{
	return (int)pos.size();
}

int VRPNTrackerInstance::getNumVelReports()
{
	return (int)vel.size();
}

int VRPNTrackerInstance::getNumAccReports()
{
	return (int)acc.size();
}

void VRPNTrackerInstance::getPosReports(vrpn_TRACKERCB** cpy, int& cnt)
{
	TrackerPosList::iterator it;
	int i = 0;
	for ( it = pos.begin(); it != pos.end(); it++ )
	{
		if (i < cnt)
		{
			vrpn_TRACKERCB* curr = *it;
			*cpy[i] = *curr;
			i++;
		}
		else
			break;
	}
	cnt = i;
}

void VRPNTrackerInstance::getVelReports(vrpn_TRACKERVELCB** cpy, int& cnt)
{
	TrackerVelList::iterator it;
	int i = 0;
	for ( it = vel.begin(); it != vel.end(); it++ )
	{
		if (i < cnt)
		{
			vrpn_TRACKERVELCB* curr = *it;
			*cpy[i] = *curr;
			i++;
		}
		else
			break;
	}
	cnt = i;
}

void VRPNTrackerInstance::getAccReports(vrpn_TRACKERACCCB** cpy, int& cnt)
{
	TrackerAccList::iterator it;
	int i = 0;
	for ( it = acc.begin(); it != acc.end(); it++ )
	{
		if (i < cnt)
		{
			vrpn_TRACKERACCCB* curr = *it;
			*cpy[i] = *curr;
			i++;
		}
		else
			break;
	}
	cnt = i;
}

