/* ========================================================================
 * PROJECT: UART
 * ========================================================================
 * Portions of this work are built on top of VRPN which was developed by
 *   Russell Taylor
 *   University of North Carolina
 * http://www.cs.unc.edu/Research/vrpn/
 *
 * We acknowledge the CISMM project at the University of North Carolina at Chapel Hill, supported by NIH/NCRR
 * and NIH/NIBIB award #2P41EB002025, for their ongoing  * support and maintenance of VRPN.
 *
 * Portions of this work are also built on top of the VideoWrapper,
 * a BSD licensed video access library for MacOSX and Windows.
 * VideoWrapper is available at SourceForge via
 * http://sourceforge.net/projects/videowrapper/
 *
 * Copyright of VideoWrapper is
 *     (C) 2003-2010 Georgia Tech Research Corportation
 *
 * Copyright of the new and derived portions of this work
 *     (C) 2010 Georgia Tech Research Corporation
 *
 * This software released under the Boost Software License 1.0 (BSL1.0), so as to be
 * compatible with the VRPN software distribution:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant,
 * this restriction and the following disclaimer, must be included in all copies of the Software, in
 * whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR
 * OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For further information regarding UART, please contact
 *   Blair MacIntyre
 *   <blair@cc.gatech.edu>
 *   Georgia Tech, School of Interactive Computing
 *   85 5th Street NW
 *   Atlanta, GA 30308
 *
 * For further information regarding VRPN, please contact
 *   Russell M. Taylor II
 *   <taylor@cs.unc.edu>
 *   University of North Carolina,
 *   CB #3175, Sitterson Hall,
 *   Chapel Hill, NC 27599-3175
 *
 * ========================================================================
 ** @author   Alex Hill (ahill@gatech.edu)
 *
 * ========================================================================
 *
 * VRPNWrapper.cpp
 *
 * Usage:
 *
 *
 * Notes:
 *
 * ========================================================================*/

#if _MSC_VER // this is defined when compiling with Visual Studio
#define EXPORT_API __declspec(dllexport) // Visual Studio needs annotating exported functions with this
#else
#define EXPORT_API // XCode does not need annotating exported functions, so define is empty
#endif

#include <math.h>
#include <string>
#include <map>
#include "vrpn_Connection.h"
#include "server_src/vrpn_Generic_server_object.h"
//#include <vrpn_Dial.h>
#include "VRPNTrackerInstance.h"
#include "VRPNAnalogInstance.h"
#include "VRPNButtonInstance.h"

// ------------------------------------------------------------------------
// Plugin itself

// Link following functions C-style (required for plugins)
extern "C"
{
#pragma ms_struct on

typedef std::map<std::string, VRPNTrackerInstance* > NameToTrackerMap;
typedef std::map<std::string, VRPNAnalogInstance* > NameToAnalogMap;
typedef std::map<std::string, VRPNButtonInstance* > NameToButtonMap;

static vrpn_Connection* connection = NULL;
static vrpn_Generic_Server_Object* server = NULL;
static NameToTrackerMap trackers;
static NameToAnalogMap analogs;
static NameToButtonMap buttons;

extern "C" void EXPORT_API MyTest()
{
	printf("MyTest!!!\n");
}

extern "C" void EXPORT_API VRPNServerStart (const char* config_file_name, const char* location, bool verbose)
{
	#if _MSC_VER
	freopen( "C:\\vrpnplugin.log", "w", stderr );
	freopen( "C:\\vrpnplugin.log", "w", stdout );
	#endif
	if (strcmp(location,"") == 0)
	{
		printf("Creating vrpn_Generic_Server_Object\n");
		//create a server connection
		if (connection == NULL)
			connection = vrpn_create_server_connection(vrpn_DEFAULT_LISTEN_PORT_NO);
		//create a server
		server = new vrpn_Generic_Server_Object(connection, config_file_name, 0, verbose);
	}
	//else, connect to the given location
	else
	{
		printf("Connecting to running vrpn server %s\n",location);
		connection = vrpn_get_connection_by_name(location);
	}
}

extern "C" void EXPORT_API VRPNServerLoop ()
{
	//run server mainloop if we created one
	if (server)
		server->mainloop();
	//iterate through the trackers and execute their mainloop
	NameToTrackerMap::iterator tkrIter = trackers.begin();
	while(tkrIter != trackers.end())
	{
		VRPNTrackerInstance* tkr = (*tkrIter).second;
		tkr->getTracker()->mainloop();
		tkrIter++;
	}
	//iterate through the analogs and execute their mainloop
	NameToAnalogMap::iterator anaIter = analogs.begin();
	while(anaIter != analogs.end())
	{
		VRPNAnalogInstance* ana = (*anaIter).second;
		ana->getAnalog()->mainloop();
		anaIter++;
	}
	//iterate through the buttons and execute their mainloop
	NameToButtonMap::iterator btnIter = buttons.begin();
	while(btnIter != buttons.end())
	{
		VRPNButtonInstance* btn = (*btnIter).second;
		btn->getButton()->mainloop();
		btnIter++;
	}
	//run connection mainloop
	if (connection)
		connection->mainloop();
}

extern "C" void EXPORT_API VRPNServerStop ()
{
	//delete the server if one was created
	if (server)
	{
		delete server;
		server = NULL;
	}
	//iterate through the trackers and delete them
	NameToTrackerMap::iterator tkrIter = trackers.begin();
	while(tkrIter != trackers.end())
	{
		VRPNTrackerInstance* tkr = (*tkrIter).second;
		delete tkr;
		tkrIter++;
	}
	trackers.erase(trackers.begin(),trackers.end());
	//iterate through the analogs and delete them
	NameToAnalogMap::iterator anaIter = analogs.begin();
	while(anaIter != analogs.end())
	{
		VRPNAnalogInstance* ana = (*anaIter).second;
		delete ana;
		anaIter++;
	}
	analogs.erase(analogs.begin(),analogs.end());
	//iterate through the buttons and delete them
	NameToButtonMap::iterator btnIter = buttons.begin();
	while(btnIter != buttons.end())
	{
		VRPNButtonInstance* btn = (*btnIter).second;
		delete btn;
		btnIter++;
	}
	buttons.erase(buttons.begin(),buttons.end());
	//remove connection reference
	connection->removeReference();
	connection = NULL;
	#if _MSC_VER
	freopen( "CON", "w", stderr );
	freopen( "CON", "w", stdout );
	#endif
}

extern "C" void EXPORT_API VRPNTrackerStart(const char* name, int type=VRPN_POS, int max=1000)
{
	if (connection == NULL) {
		printf("Error: VRPNTrackerStart executed before server has beeen started\n");
		return;
	}
	std::string device(name);
	//find if remote object exists
	VRPNTrackerInstance* tkr = trackers[device];
	//if not, create a remote tracker object
	if (tkr == NULL)
	{
		tkr = new VRPNTrackerInstance(name, connection);
		trackers[device] = tkr;
	}
	tkr->setMaxReports(max);
	tkr->setReportTypes(type);
}

extern "C" void EXPORT_API VRPNTrackerPosReport(const char* name, vrpn_TRACKERCB* cpy, timeval* ts, int sensor=0)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		tkr->getPosReport(cpy,ts,sensor);
	}
}

extern "C" void EXPORT_API VRPNTrackerVelReport(const char* name, vrpn_TRACKERVELCB* cpy, timeval* ts, int sensor=0)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		tkr->getVelReport(cpy,ts,sensor);
	}
}

extern "C" void EXPORT_API VRPNTrackerAccReport(const char* name, vrpn_TRACKERACCCB* cpy, timeval* ts, int sensor=0)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		tkr->getAccReport(cpy,ts,sensor);
	}
}

extern "C" int EXPORT_API VRPNTrackerNumPosReports(const char* name)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		return tkr->getNumPosReports();
	}
	return 0;
}

extern "C" int EXPORT_API VRPNTrackerNumVelReports(const char* name)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		return tkr->getNumVelReports();
	}
	return 0;
}

extern "C" int EXPORT_API VRPNTrackerNumAccReports(const char* name)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		return tkr->getNumAccReports();
	}
	return 0;
}

extern "C" void EXPORT_API VRPNTrackerPosReports(const char* name, vrpn_TRACKERCB** cpy,int& cnt)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr != NULL)
	{
		tkr->getPosReports(cpy,cnt);
	}
}

extern "C" void EXPORT_API VRPNTrackerVelReports(const char* name, vrpn_TRACKERVELCB** cpy,int& cnt)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		return tkr->getVelReports(cpy,cnt);
	}
}

extern "C" void EXPORT_API VRPNTrackerAccReports(const char* name, vrpn_TRACKERACCCB** cpy,int& cnt)
{
	std::string device(name);
	VRPNTrackerInstance* tkr = trackers[device];
	if (tkr)
	{
		return tkr->getAccReports(cpy,cnt);
	}
}

extern "C" void EXPORT_API VRPNAnalogStart(const char* name, int max=1000)
{
	if (connection == NULL) {
		printf("Error: VRPNAnalogStart executed before server has beeen started\n");
		return;
	}
	std::string device(name);
	//find if remote object exists
	VRPNAnalogInstance* ana = analogs[device];
	//if not, create a remote analog object
	if (ana == NULL)
	{
		ana = new VRPNAnalogInstance(name, connection);
		analogs[device] = ana;
	}
	ana->setMaxReports(max);
}

extern "C" int EXPORT_API VRPNAnalogNumReports(const char* name)
{
	std::string device(name);
	VRPNAnalogInstance* ana = analogs[device];
	if (ana)
	{
		return ana->getNumReports();
	}
	return 0;
}

extern "C" void EXPORT_API VRPNAnalogReports(const char* name, vrpn_ANALOGCB** cpy, int& cnt, timeval* ts, bool clearReport)
{
	std::string device(name);
	VRPNAnalogInstance* ana = analogs[device];
	if (ana)
	{
		return ana->getReports(cpy, cnt, ts, clearReport);
	}
}


extern "C" void EXPORT_API VRPNButtonStart(const char* name, int max=1000)
{
	if (connection == NULL) {
		printf("Error: VRPNButtonStart executed before server has beeen started\n");
		return;
	}
	std::string device(name);
	//find if remote object exists
	VRPNButtonInstance* btn = buttons[device];
	//if not, create a remote button object
	if (btn == NULL)
	{
		btn = new VRPNButtonInstance(name, connection);
		buttons[device] = btn;
	}
	btn->setMaxReports(max);
}

extern "C" int EXPORT_API VRPNButtonNumReports(const char* name)
{
	std::string device(name);
	VRPNButtonInstance* btn = buttons[device];
	if (btn)
	{
		return btn->getNumReports();
	}
	return 0;
}

extern "C" void EXPORT_API VRPNButtonReports(const char* name, vrpn_BUTTONCB** cpy, int& cnt, timeval* ts, int btn_num, bool clearReport)
{
	std::string device(name);
	VRPNButtonInstance* btn = buttons[device];
	if (btn)
	{
		return btn->getReports(cpy, cnt, ts, btn_num, clearReport);
	}
}



extern "C" bool EXPORT_API VRPNTimevalGreater(timeval* tv1, timeval* tv2)
{
	return vrpn_TimevalGreater(*tv1, *tv2);
}

} // end of export C block

int main()
{
	// VRPNServerStart();
	// VRPNServerLoop();
	// VRPNServerStop();
	return 0;
}
